{"version":3,"sources":["assets/Scripts/Framework/Event/EventManager.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["// Learn TypeScript:\n//  - https://docs.cocos.com/creator/2.4/manual/en/scripting/typescript.html\n// Learn Attribute:\n//  - https://docs.cocos.com/creator/2.4/manual/en/scripting/reference/attributes.html\n// Learn life-cycle callbacks:\n//  - https://docs.cocos.com/creator/2.4/manual/en/scripting/life-cycle-callbacks.html\n\n\n\nconst {ccclass, property} = cc._decorator;\n/**\n * 回调函数，有两个参数，事件名和函数所需数据\n */\nexport type EventManagerCallFunc=(eventName:string,eventData:any)=>void;\n/**\n * 事件名对应的回调函数，callback是触发的函数，target是函数所在的脚本\n */\ninterface CallBackTarget\n{\n    callBack:EventManagerCallFunc,\n    target:any,\n}\n@ccclass\nexport class EventManager {\n    private static _instance:EventManager;\n    public static get Instance()\n    {\n        if(this._instance==null)\n        {\n            this._instance=new EventManager();\n        }\n        return this._instance as EventManager;\n    }\n    private constructor(){}\n    /**用来存储所有已添加的事件和对应回调函数的字典集合，key：事件名，value：callbacktarget数组 */\n    private eventListeners:{[key:string]:CallBackTarget[]}={};\n\n    //这个方法用于判断当前要添加的事件是否已经添加过了，如果说已经添加过了，就不再添加，如果没添加过继续添加就是一个eventName触发多个方法（因为这个方法只有当这个eventName对应的方法数组不为空时才会触发）\n    private getEventListenersIndex(eventName:string,callBack:EventManagerCallFunc,target:any):number\n    {\n        let index=-1;\n        for(let i=0;i<this.eventListeners[eventName].length;i++)\n        {\n            let iterator=this.eventListeners[eventName][i];\n            if(iterator.callBack==callBack&&(!target||iterator.target==target))\n            {\n                index=i;\n                break;\n            }\n        }\n        return index;\n    }\n    /**\n     * 添加事件\n     * @param eventName 事件名\n     * @param callBack 事件回调函数\n     * @param target 函数所在脚本（一般是this）\n     * @returns \n     */\n    addEventListener(eventName:string,callBack:EventManagerCallFunc,target?:any):boolean\n    {\n        if(!eventName)\n        {\n            console.log(\"事件名有错误\");\n            return;\n        }\n        if(callBack==null)\n        {\n            console.log(\"事件传入的方法为空\");\n            return false;\n        }\n        let callTarget:CallBackTarget={callBack:callBack,target:target};\n        if(this.eventListeners[eventName]==null)\n        {\n            this.eventListeners[eventName]=[callTarget];\n        }\n        else\n        {\n            let index=this.getEventListenersIndex(eventName,callBack,target);\n            if(index==-1)\n            {\n                this.eventListeners[eventName].push(callTarget);\n            }\n        }\n        return true;\n    }\n    /**\n     * 设置事件名对应的事件函数\n     * @param eventName \n     * @param callBack \n     * @param target \n     * @returns \n     */\n    setEventListener(eventName:string,callBack:EventManagerCallFunc,target?:any):boolean\n    {\n        if(!eventName)\n        {\n            console.log(\"事件名为空\");\n            return;\n        }\n        if(callBack==null)\n        {\n            console.log(\"传入的事件函数为空\");\n            return false;\n        }\n        let callBackFunc:CallBackTarget={callBack:callBack,target:target};\n        this.eventListeners[eventName]=[callBackFunc];\n    }\n    /**\n     * 删除函数\n     * @param eventName 事件名\n     * @param callBack 事件回调函数\n     * @param target 函数所在的脚本（一般是this）\n     */\n    removeEventListener(eventName:string,callBack:EventManagerCallFunc,target?:any)\n    {\n        if(this.eventListeners[eventName]!=null)\n        {\n            let index=this.getEventListenersIndex(eventName,callBack,target);\n            if(index!=-1)\n            {\n                this.eventListeners[eventName].splice(index,1);\n            }\n        }\n    }\n    /**\n     * 触发事件（如果事件对应的方法没有数据参数需求即可只传一个参数）\n     * @param eventName 事件名参数\n     * @param eventData 数据参数\n     */\n    dispatch(eventName:string,eventData?:any)\n    {\n        if(this.eventListeners[eventName]!=null)\n        {\n            // 将所有回调提取出来，再调用，避免调用回调的时候操作了事件的删除\n            let callBackList:CallBackTarget[]=[];\n            for (const iterator of this.eventListeners[eventName]) {\n                callBackList.push({ callBack: iterator.callBack, target: iterator.target });\n            }\n            for (const iterator of callBackList) {\n                //call方法意思是调用第一个参数（此时一般传入的是当时添加这个事件的脚本）脚本上callback方法，callback是一个EventManagerCallFunc类型，有两个参数，所以call后面两个参数就是传给这个target身上的callback方法的。第一个是事件名称，一般没用，第二个是传入的数据\n                iterator.callBack.call(iterator.target, eventName, eventData);\n            }\n        }\n    }\n\n    // update (dt) {}\n}\n"]}